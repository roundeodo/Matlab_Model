function complex_envelope = iq_downmixer(signal, osr, br, fc, fs)

% TODO: You may want to implement a better downsampling filter.
% TIP: Look up 'CIC' filters as inspiration for an efficient hardware 
% implementation. Also think about how you will generate the LO signal in
% hardware, looking up 'CORDIC' will set you in a correct direction.

% IQ downmixer
t = ((1 : numel(signal))' - 1) / fs;
upsampled_envelope = 2 * exp(-1j * 2 * pi * fc * t) .* signal;

% apply a simple downsampling filter
% filt = ones(2 * round(fs / (br * osr)) + 1);
% upsampled_envelope = conv(upsampled_envelope, filt / sum(filt), 'same');

% 选择 CIC 滤波器参数
M = 1;   % 差分阶数，一般设为 1
N = 5;   % 级联级数，适用于高倍率降采样

% 计算输入信号长度
L = length(upsampled_envelope);

% 计算需要填充的 0 的数量
R = round(fs / (br * osr)); % 降采样因子
padding_size = mod(-L, R); % 计算 L 需要增加到 R 的整数倍

% 如果 padding_size > 0，则填充 0
if padding_size > 0
    upsampled_envelope = [upsampled_envelope; zeros(padding_size, 1)];
end

cic_decim = dsp.CICDecimator(R, M, N);

% 现在信号长度是 R 的整数倍，调用 CIC 过滤器
upsampled_envelope = cic_decim(upsampled_envelope);



% % calculate number of output samples
% n1 = numel(upsampled_envelope);
% n2 = round((n1 - 1) * (br * osr) / fs) + 1;
% 
% % resample the complex envelope to the new sample rate
% t1 = ((1 : n1)' - 1) / fs;
% t2 = ((1 : n2)' - 1) / (br * osr);
% complex_envelope = interp1(t1, upsampled_envelope, t2);

end